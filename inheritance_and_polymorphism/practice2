1. Статические методы связаны с классом, а не с объектом
Статические методы принадлежат классу, а не объекту. Они вызываются через имя класса (A.method()), а не через объект 
(a.method()).
Динамический полиморфизм работает с объектами, используя механизм виртуальной таблицы (vtable) для вызова метода в зависимости 
от типа объекта, на который указывает ссылка.
Но статические методы не используют объекты или ссылки для вызова. Вместо этого вызов A.method() или B.method() явно указывает,
какой метод будет вызван на этапе компиляции, а не выполнения.
2. Отсутствие vtable для статических методов
Для обычных (нестатических) методов компилятор использует виртуальную таблицу (vtable) для разрешения метода, который нужно 
вызвать.
Для статических методов vtable не создается, потому что они привязаны к классу, а не к объекту. Вызов A.method() и B.method() 
известен уже на этапе компиляции, и никакой динамической выборки не требуется.
Это делает невозможным переопределение статических методов через механизм наследования.
3. Аннотация @Override не работает для статических методов
Попытка использовать @Override для статического метода вызовет ошибку компиляции. Это потому, что статические методы 
не переопределяются, а скрываются.
Если метод с тем же именем и параметрами объявлен в подклассе, это скрытие метода, а не полиморфизм.
Пример:

A a = new B();
a.method(); // Вызовет A.method(), а не B.method(), т.к. метод статический
4. Статические методы скрываются, но не переопределяются
Если вы объявите статический метод с таким же именем и сигнатурой в подклассе, как и в суперклассе, метод суперкласса будет 
скрыт, а не переопределен.
Это означает, что вызов A.method() и B.method() всегда будет определен на этапе компиляции по типу ссылки.
Например:

A a = new B();
a.method(); // Вызовет A.method(), т.к. статические методы определяются по типу ссылки, а не по типу объекта

B b = new B();
b.method(); // Вызовет B.method()
