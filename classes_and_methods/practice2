Что происходит в цикле for (1)

for (Number n : num) {
    a.printNum(n);
}
В массиве num элементы имеют тип Number, так как массив объявлен как Number[] num.

Типы элементов массива:

Number[] num = { new Integer(1), 11, 1.11f, 11.11 };
new Integer(1) — это объект типа Integer (явно созданный).
11 — это int, но при добавлении в массив типа Number[] он автоматически упаковывается (autoboxing) в Integer.
1.11f — это float, который упаковывается в объект Float.
11.11 — это double, который упаковывается в объект Double.
Вызывается метод a.printNum(n) для каждого элемента.
Тип переменной n в цикле — это Number, а не конкретные типы Integer, Float или Double.

Разрешение перегрузки (выбор метода)
В момент компиляции тип n известен как Number, и это статический тип.
При вызове a.printNum(n), компилятор смотрит на методы класса A и пытается найти наиболее подходящий метод для типа Number.
Самый точный вариант из списка доступных методов — это метод:

public void printNum(Number n) { System.out.println("Number=" + n); }
Почему не вызываются методы для int, Integer или Float?

Метод для int не подходит, потому что Number не может быть автоматически приведён к int.
Метод для Integer не подходит, потому что n — это Number, а не Integer.
Метод для Float не подходит по той же причине.
Метод для Number точно соответствует типу переменной n, и именно он будет вызван.
Итог для for (1):

Number=1
Number=11
Number=1.1100
Number=11.11
Что происходит при вызовах (2)

a.printNum(new Integer(1));
a.printNum(11);
a.printNum(1.11f);
a.printNum(11.11);
Здесь аргументы каждого метода передаются явно, и компилятор знает их типы на этапе компиляции, поэтому перегрузка разрешается по фактическим типам аргументов.

1. a.printNum(new Integer(1));
Аргумент — Integer, поэтому компилятор вызывает метод:

public void printNum(Integer i) { System.out.printf("Integer = %d%n", i); }
2. a.printNum(11);
Аргумент — int, поэтому компилятор вызывает метод:

public void printNum(int i) { System.out.printf("int = %d%n", i); }
3. a.printNum(1.11f);
Аргумент — float, который автоматически упаковывается в Float.
Компилятор вызывает метод:

public void printNum(Float f) { System.out.printf("Float = %.4f%n", f); }
4. a.printNum(11.11);
Аргумент — double, но метод для double отсутствует.
Компилятор проверяет, к какому типу он может привести double.
double можно автоматически упаковать в Double, но метода printNum(Double d) нет.
Следовательно, компилятор будет использовать самый общий метод:

public void printNum(Number n) { System.out.println("Number=" + n); }
Итог для (2):


Integer = 1
int = 11
Float = 1.1100
Number=11.11
Итоговое различие
Цикл (1)	Вызовы (2)
Number=1	Integer = 1
Number=11	int = 11
Number=1.1100	Float = 1.1100
Number=11.11	Number=11.11

Тип переменной в цикле
В цикле тип n — это Number, поэтому вызывается метод с параметром Number, а не с параметрами int, Integer или Float.

Определение типа во время компиляции
При явных вызовах (a.printNum(11)) компилятор знает точный тип аргумента и находит наиболее подходящий метод на основе перегрузки методов.

Основные выводы
В цикле for (1) метод printNum(Number n) вызывается для всех значений, так как тип переменной n — Number, и этот метод является наиболее подходящим среди доступных 
перегруженных методов.
В вызовах (2) перегрузка происходит на этапе компиляции, и компилятор выбирает метод на основе фактического типа аргумента.
Если в классе есть перегруженные методы с более специфическими типами (Integer, Float, int), они будут использоваться в явных вызовах, но не при передаче объекта 
типа Number.
Как исправить и получить одинаковое поведение?
Если вы хотите, чтобы цикл (1) вызывал методы для конкретных типов (например, printNum(Integer) для new Integer(1)), то вы можете использовать оператор instanceof и 
явное приведение типов:

for (Number n : num) {
    if (n instanceof Integer) a.printNum((Integer) n);
    else if (n instanceof Float) a.printNum((Float) n);
    else a.printNum(n);
}
Или используйте метод a.printNum(n.intValue()) или a.printNum(n.floatValue()), чтобы заставить компилятор вызвать нужную перегрузку.

